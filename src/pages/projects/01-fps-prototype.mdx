---
blurb: "Built with Unreal Engine 5"
draft: false
layout: ../../layouts/ProjectLayout.astro
title: "First-Person Shooter Prototype"
---

<div class="flexbox-vertical note">
  A first-person shooter prototype featuring a variety of playable characters, weapons, and abilities. Built from scratch in Unreal Engine 5 using C++ and Blueprints along with:
  
  - Unreal Engine Gameplay Ability System (GAS)
  - Unreal Engine Common UI
  - Behavior trees for enemy and companion AI
</div>

[VIDEO TODO]

<div class="flexbox-vertical note">
  # Asset Credits

  To speed up development and allow myself to focus on design and coding, I utilized premade assets from these sources:
  
  - TODO
</div>

## Overview

Inspired by the story-driven campaigns of games like _Titanfall 2_ and _Uncharted_, the weapon systems of games like _Halo_ and _Call of Duty_, and the companion mechanics of games like _Mass Effect_ and _Gears of War_, I created this project to practice the design and implementation of various interconnecting game systems and mechanics.

## Controls

Using Unreal Engine 5’s **Enhanced Input** system, I implemented the game’s controls for both gamepads and mouse/keyboard.

In designing this control scheme, my goal was to support a **wide variety of actions** while keeping the controls as **simple and intuitive** as possible. Tap/hold triggers allow a single button to support multiple actions in a way that is, hopefully, easy for the player to remember and execute. For accessibility purposes, the hold time threshold for these controls could be made customizable by the player.

### Gamepad Controls

<img alt="A diagram of a video game control scheme overlaid on top of a photo of an Xbox controller" src="/images/projects/fps-prototype/controls-gamepad.png" width="700" />

### Mouse/Keyboard Controls

<div class="flexbox-horizontal flexbox-horizontal-blocks">

| Input | Action |
| -------- | ------- |
| **W/A/S/D** | Walk/Run |
| **Shift** | Sprint |
| **Mouse-X/Y** | Adjust Camera |
| **X** | Melee Attack |
| **Spacebar** | Jump |
| **C** | Crouch |
| **E** | Interact |
| **R (tap)** | Reload |
| **R (hold)** | Open Special Ability Wheel |
| **Escape** | Pause Game |

| Input | Action |
| -------- | ------- |
| **RMB** | Aim Down Sights |
| **RMB + F** | Aim Grenade |
| **Command** | Special Ability |
| **LMB** | Fire Weapon/Throw Grenade |
| **1** | Switch to Squad Member 1 |
| **2** | Switch to Squad Member 2 |
| **3** | Primary Weapon |
| **4** | Secondary Weapon |
| **5 (tap)** | Quick Info |
| **5 (hold)** | Switch Camera Mode |

</div>

## Camera

Although the game is designed to be an FPS, I wanted to practice working with different camera systems, so I implemented a camera that can switch between **first-person and third-person (over-the-shoulder) modes**.

<iframe class="yt-iframe" width="560" height="315" src="https://www.youtube-nocookie.com/embed/vuDTP0blgtA?si=jrElcXxS3jBrVRyH" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

To support multiple camera perspectives, I used a separate first-person (“arms only”) and third-person skeletal mesh for each playable character. I shared animations between these meshes by creating an **IK Retargeter** for each unique skeleton in Unreal Engine and retargeting animations between them.

<img alt="A screenshot of an IK Retargeter in Unreal Engine showcasing two different skeletal meshes arranged in similar T-poses." src="/images/projects/fps-prototype/ik-retargeting.png" width="700" />

I used a variety of techniques and tools inside an **Animation Blueprint** to implement smooth animation transitions for each skeleton, including animation state machines, blended poses, Blend Spaces, and Aim Offsets.

<iframe class="yt-iframe" width="560" height="315" src="https://www.youtube-nocookie.com/embed/s_AA11w8exg?si=jrfXnS-YDM5iM6sg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<div class="flexbox-horizontal flexbox-horizontal-blocks">
  <img alt="A screenshot of an Animation Blueprint inside Unreal Engine" class="flex-grow-1" src="/images/projects/fps-prototype/animation-blueprint-1.png" width="400" />

  <img alt="A screenshot of an Animation Blueprint inside Unreal Engine" class="flex-grow-1" src="/images/projects/fps-prototype/animation-blueprint-2.png" width="400" />
</div>

## Gameplay Abilities

Most significant actions in the game are implemented using Unreal Engine’s **Gameplay Ability System (GAS)**. Using GAS allowed me to not only tap into a robust system of activation, blocking, and cancellation capabilities, but to do so in a clean and organized way.

### Sprinting

I integrated GAS cost and cooldown capabilities with sprinting to build a **stamina regeneration** mechanic. The amount of stamina a character has, how quickly it is depleted by actions like sprinting, and the rate at which it regenerates can all be configured through gameplay attributes.

A character’s base walking speed and max sprint speed can also be configured through gameplay attributes. This allows for designing a variety of enemies and companions with different movement speeds based on their innate stats.

<iframe class="yt-iframe" width="560" height="315" src="https://www.youtube-nocookie.com/embed/kXXaiM-HnN8?si=DCpwGBlKH47MJQLM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<img alt="An animated GIF of a video game stamina bar emptying and refilling" src="/images/projects/fps-prototype/stamina-bar.gif" />

### Aim Down Sights (ADS)

When aiming down sights, the player’s crosshair gets tighter to indicate higher shooting accuracy. The camera smoothly interpolates to a narrower field of view, and the player’s camera speed slows down to facilitate more accurate targeting.

<iframe class="yt-iframe" width="560" height="315" src="https://www.youtube-nocookie.com/embed/MhAoixCCYHE?si=oXEdrlvFWA40kYkU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Reloading

When a character reloads, a reloading Animation Montage is played. The montage’s underlying Animation Sequence triggers cosmetic effects like sound cues (SFX) and particle systems (VFX). As the montage finishes, a set of ammo-related gameplay attributes is calculated and updated, which is immediately reflected in the player’s HUD.

<iframe class="yt-iframe" width="560" height="315" src="https://www.youtube-nocookie.com/embed/KYejliLJBoc?si=FAI47keQAIxPihMZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<img alt="An animated GIF of a video game HUD element tracking ammo as a weapon is fired and reloaded" src="/images/projects/fps-prototype/ammo-display.gif" />

### Weapon Switching

In this game, each character can carry two weapons at a time. When switching weapons, a section of an Animation Montage is played based on the weapon types the character is transitioning between (one-handed weapon to two-handed weapon or vice versa).

The underlying Animation Sequence triggers various SFX and VFX and also notifies when each weapon’s mesh should be attached to a particular socket on the character’s skeletal mesh (e.g., hand versus holster).

[VIDEO TODO]

### Character Switching

In this prototype, I wanted to be able to immediately play with a variety of character types and weapons, so I implemented a system in which **every companion is also a playable character**.

When the player switches between characters, the screen briefly fades to white and a Sound Cue plays to indicate the transition. Under the hood, C++ code executes teardown logic on the departing character to prepare it for AI control (switching from a first-person mesh to a third-person mesh, starting Behavior Tree logic, etc.). Similarly, setup logic is executed on the incoming character to prep it for player control.

[VIDEO TODO]

### Melee Attacks

During a melee attack, an Animation Montage is played, which triggers a **Notify State** that creates and then eventually destroys a **hitbox**. Hostile characters that overlap with this hitbox play a hit reaction animation and are dealt damage.

[VIDEO TODO]

Since shooting is the primary form of combat in this prototype, the melee system is very simple. In a more complex melee combat system, unique attacks could be designed to use hitboxes of different sizes, shapes, placements, and quantities. Systems like soft locking could also be implemented using **motion warping** to aid the player’s accuracy.

## Shooting

The three types of guns in this prototype—pistols, assault rifles, and shotguns—are implemented as **hitscan** weapons.

Shooting is implemented as a GAS **gameplay ability**. The ability code performs various line traces and calculations to execute each shot alongside triggering relevant animations, SFX, VFX, hit reactions, and damage gameplay effects. It utilizes GAS costs to consume weapon ammo and GAS cooldowns to enforce a maximum rate of fire.

### Spread

To implement spread, a bullet’s trajectory is **randomized within a cone originating from the gun’s muzzle**. The cone’s diameter could be calculated using gameplay attributes and other flags, such as whether the character is running or standing still. This would allow for combat variability based on weapon stats, character stats, and player behaviors.

[VIDEO TODO]

Weapons like shotguns can be configured to fire multiple projectiles at once.

[VIDEO TODO]

### Recoil

After firing a weapon, **viewkick** is temporarily added to the viewport to simulate recoil. The direction and severity at which viewkick affects the camera’s pitch and yaw—as well as the rate of viewkick recovery (**centerspeed**)—could be configured for each unique weapon, allowing for a variety of differentiated weapon designs.

[VIDEO TODO]

### Aim Assist

To assist the player’s targeting accuracy, the camera movement speed slows down slightly when the player’s reticle is near or on top of a hostile target.

[VIDEO TODO]

## Scripting

I implemented a system that would allow me to trigger scripted events and behaviors within a level in a data-driven way.

**NPC barks** can be triggered, which utilize **Dialogue Waves** to play audio (in this prototype, placeholder audio is used in lieu of recorded dialogue). Subtitles are displayed in the HUD for accessibility. Barks can trigger other barks, allowing NPCs to respond to each other.

[VIDEO TODO]

**Mission objectives and tutorials** can be triggered and displayed in the HUD.

[VIDEO TODO]

Scripted behaviors for NPCs can be triggered, such as gesture animations and targeted movement.

[VIDEO TODO]

## Companion AI

Companion logic is implemented in a **Behavior Tree**.

Companions can be targeted at a particular location, encouraging the player to follow them.

[VIDEO TODO]

When not in combat and not targeted at a location, companions will generally follow the player.

[VIDEO TODO]

To avoid impeding the player’s movement, companions will move out of the way if the player bumps into them. This behavior uses **Environment Query System (EQS)** queries to find a reasonable nearby location for the NPC to go.

[VIDEO TODO]

**Nav Link Proxies** are used to bridge separated areas within the level’s **Navigation Mesh**. Companions will use these links to follow the player, performing relevant movements like opening doors and mantling onto objects along the way.

[VIDEO TODO]

## Enemy AI

Enemy logic is implemented in a **Behavior Tree**.

Enemies not engaged in combat can be posted at a particular location or walk along a patrol route.

[VIDEO TODO]

Through an **AI Perception Component**, enemies can detect when the player is nearby. When the player first enters an enemy’s sight line, the enemy turns toward the player and plays an audio bark to indicate that the player has been spotted. If other enemies are nearby, they will also be alerted to the player’s presence (this is accomplished through an **instance synced Blackboard key** that is shared across related enemies).

[VIDEO TODO]

## Level Design

## UI
